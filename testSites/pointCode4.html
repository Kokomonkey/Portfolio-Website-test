<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Line of Sight - Offset Control</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #ffffff;
            overflow: hidden;
            font-family: sans-serif;
        }
        canvas {
            display: block;
        }
        
        /* The Toggle Button */
        #offset-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100; /* Ensures it sits above the canvas */
            padding: 12px 24px;
            background-color: white;
            color: black;
            border: 2px solid black;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 1s ease;
        }

        #offset-btn:hover {
            background-color: #000000;
            color: white;
        }

        /* State for when the button is active */
        #offset-btn.active {
            background-color: #ff0000; /* Red to match the vision */
            border-color: #ff0000;
            color: white;
        }
    </style>
</head>
<body>

<button id="offset-btn">Block View</button>
<canvas id="canvas"></canvas>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const btn = document.getElementById('offset-btn');

    // Configuration
    const config = {
        numRects: 12,
        rectWidth: 150,
        rectHeight: 18,
        gap: 80,
        cornerRadius: 0,
        lightOpacity: 0.65,
        lightBorder: 10,
        lightRadiusPercent: 0.15,
        offsetDegrees: 25 // The requested offset
    };

    let width, height;
    let mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
    let rectangles = [];
    let isOffsetActive = false; // Tracks if button is clicked

    // --- Initialization and Events ---

    function init() {
        resize();
        window.addEventListener('resize', resize);
        document.addEventListener('mousemove', onMouseMove);
        
        // Button Logic
        btn.addEventListener('click', () => {
            isOffsetActive = !isOffsetActive;
            btn.classList.toggle('active');
            btn.innerText = isOffsetActive ? "View Blocked" : "Block View";
        });

        createRectangles();
        animate();
    }

    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        createRectangles();
    }

    function onMouseMove(e) {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
    }

    function createRectangles() {
        rectangles = [];
        const totalWidth = (config.numRects * config.gap) - config.gap;
        const startX = (width / 2) - (totalWidth / 2);
        const centerY = height / 2;

        for (let i = 0; i < config.numRects; i++) {
            rectangles.push({
                cx: startX + (i * config.gap),
                cy: centerY,
                angle: 0
            });
        }
    }

    // --- The Math ---

    function roundedRectPath(ctx, x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
    }

    function rotatePoint(px, py, cx, cy, angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const nx = (cos * (px - cx)) - (sin * (py - cy)) + cx;
        const ny = (sin * (px - cx)) + (cos * (py - cy)) + cy;
        return { x: nx, y: ny };
    }

    function getRectCorners(rect) {
        const hw = config.rectWidth / 2;
        const hh = config.rectHeight / 2;
        const p1 = { x: rect.cx - hw, y: rect.cy - hh };
        const p2 = { x: rect.cx + hw, y: rect.cy - hh };
        const p3 = { x: rect.cx + hw, y: rect.cy + hh };
        const p4 = { x: rect.cx - hw, y: rect.cy + hh };
        
        return [
            rotatePoint(p1.x, p1.y, rect.cx, rect.cy, rect.angle),
            rotatePoint(p2.x, p2.y, rect.cx, rect.cy, rect.angle),
            rotatePoint(p3.x, p3.y, rect.cx, rect.cy, rect.angle),
            rotatePoint(p4.x, p4.y, rect.cx, rect.cy, rect.angle)
        ];
    }

    function projectPoint(px, py, lx, ly, magnitude = 10000) {
        const dx = px - lx;
        const dy = py - ly;
        const len = Math.sqrt(dx*dx + dy*dy);
        return {
            x: px + (dx / len) * magnitude,
            y: py + (dy / len) * magnitude
        };
    }

    // --- The Animation Loop ---

    function animate() {
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0,0,width,height);

        // 1. Update angles based on mouse position + Offset Logic
        rectangles.forEach(rect => {
            const deltaX = mouse.x - rect.cx;
            const deltaY = mouse.y - rect.cy;
            let targetAngle = Math.atan2(deltaY, deltaX);

            // Apply 15 degree offset if button is active
            if (isOffsetActive) {
                const radians = config.offsetDegrees * (Math.PI / 180);
                targetAngle += radians;
            }

            rect.angle = targetAngle;
        });

        // --- LAYER 1: The Red Vision ---
        ctx.save();
        const lightRadius = width * config.lightRadiusPercent;
        ctx.beginPath();
        ctx.arc(mouse.x, mouse.y, lightRadius, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 0, 0, ${config.lightOpacity})`;
        ctx.fill();
        ctx.lineWidth = config.lightBorder;
        ctx.strokeStyle = 'red';
        ctx.stroke();
        ctx.restore();


        // --- LAYER 2: The Shadows (Erasing) ---
        ctx.save();
        ctx.globalCompositeOperation = 'destination-out';
        ctx.fillStyle = 'black'; 

        rectangles.forEach(rect => {
            const corners = getRectCorners(rect);
            
            for(let i = 0; i < corners.length; i++) {
                const c1 = corners[i];
                const c2 = corners[(i + 1) % corners.length]; 

                const p1 = projectPoint(c1.x, c1.y, mouse.x, mouse.y);
                const p2 = projectPoint(c2.x, c2.y, mouse.x, mouse.y);

                ctx.beginPath();
                ctx.moveTo(c1.x, c1.y);
                ctx.lineTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.lineTo(c2.x, c2.y);
                ctx.closePath();
                ctx.fill();
            }
        });
        ctx.restore();


        // --- LAYER 3: The Obstacles ---
        ctx.fillStyle = '#000000';
        rectangles.forEach(rect => {
            ctx.save();
            ctx.translate(rect.cx, rect.cy);
            ctx.rotate(rect.angle);
            roundedRectPath(ctx, -config.rectWidth/2, -config.rectHeight/2, config.rectWidth, config.rectHeight, config.cornerRadius);
            ctx.fill();
            ctx.restore();
        });

        requestAnimationFrame(animate);
    }

    init();

</script>
</body>
</html>